# Adding New Encoders

This guide explains how to add new encoders to usenc.

## Quick Start

Adding a new encoder is simple thanks to automatic discovery:

1. Create a new file in `src/usenc/encoders/`
2. Define an `Encoder` subclass
3. Add docstrings for automatic documentation
4. Define tests
5. Done! It's automatically registered

## Step-by-Step Example

Let's create a hex encoder:

### 1. Create the File

Create `src/usenc/encoders/hex.py`:

```python
from .base import Encoder

class HexEncoder(Encoder):
    @staticmethod
    def encode(text: str) -> str:
        ...
        return encoded_text

    @staticmethod
    def decode(text: str) -> str:
        ...
        return decoded_text
```

### 2. Add custom parameters

Parameters are generated by the `params` dict

#### Parameter Specification

Each parameter in the `params` dict should have:

- `type`: The parameter type (`str`, `bool`, `int`, etc.)
- `default`: Default value if not provided
- `action` (optional): How argparse processes the param (`store_true`, `store_false`, ...)
- `help`: Help text shown in CLI

#### Example

```python
from .base import Encoder

class HexEncoder(Encoder):

    params = {
        'prefix': {
            'type': str,
            'default': '',
            'help': 'Prefix string to each encoded character'
        },
        'lowercase': {
            'action': 'store_true',
            'help': 'Use lowercase hex digits'
        }
    }

    @staticmethod
    def encode(text: str, prefix: str, lowercase: bool) -> str:
        ...
        return encoded_text

    @staticmethod
    def decode(text: str, prefix: str, lowercase: bool) -> str:
        ...
        return decoded_text
```

### 3. Adding Documentation

Documentation is generated from docstrings in the Encoder class:

```python
from .base import Encoder

class HexEncoder(Encoder):
    """
    Hexadecimal string encoding

    Encodes each character with its hex representation

    Examples:
    hello world -> 68656C6C6F20776F726C64
    url$param+ -> 75726C253234706172616D253242
    """

    params = {
        'prefix': {
            'type': str,
            'default': '',
            'help': 'Prefix string to each encoded character'
        },
        'lowercase': {
            'action': 'store_true',
            'help': 'Use lowercase hex digits'
        }
    }

    @staticmethod
    def encode(text: str, prefix: str, lowercase: bool) -> str:
        ...
        return encoded_text

    @staticmethod
    def decode(text: str, prefix: str, lowercase: bool) -> str:
        ...
        return decoded_text
```

Parameters are automatically added to the CLI:

```bash
usenc hex --prefix "0x" --lowercase
```

### 4. Adding Tests

Tests are generated by the `tests` dict

Specify a test name and the arguments used for the test. It will automatically run a snapshot test and a round-trip test with the samples in `tests/snapshots/samples.txt`.

```python
from .base import Encoder

class HexEncoder(Encoder):
    """
    Hexadecimal string encoding

    Encodes each character with its hex representation

    Examples:
    hello world -> 68656C6C6F20776F726C64
    url$param+ -> 75726C253234706172616D253242
    """

    params = {
        'prefix': {
            'type': str,
            'default': '',
            'help': 'Prefix string to each encoded character'
        },
        'lowercase': {
            'action': 'store_true',
            'help': 'Use lowercase hex digits'
        }
    }

    tests = Encoder.tests | {
        'prefix': '--prefix 0x',
        'include': '--prefix 0x --include ghij',
        'exclude': '--exclude abcd',
        'include_all': '--include all',
        'include_all_except_one': '--include all --exclude g',
        'lowercase': '--lowercase'
    }

    @staticmethod
    def encode(text: str, prefix: str, lowercase: bool) -> str:
        ...
        return encoded_text

    @staticmethod
    def decode(text: str, prefix: str, lowercase: bool) -> str:
        ...
        return decoded_text
```

### 5. That's It!

The encoder is automatically discovered and registered as `hex`.

The naming convention is:
- Class name: `{Name}Encoder` → registered as `{name}`
- Example: `HexEncoder` → `base64`

## Testing

### Manual Testing

Test from CLI:

```bash
echo "test data" | usenc hex
echo "test data" | usenc hex | usenc -d enc
```

### Unit Tests

There are two main types on tests: snapshots tests and round-trips tests. Snapshots take a sample list as input (always `tests/snapshots/samples.txt`), encode each line and compare it with a result file `tests/snapshots/hex/base.txt`.

If the result file does not exist, it will save the encoded input as the result file. So to re-generate snapshots you can simply delete the associated files in `tests/snapshots/hex`

**Make sure the snapshots are what you expect from your encoder**

Round-trips tests are similar but instead of comparing with a result file, it will encode and decode each sample and check if it is equal.

Run the test suite with `pytest`. 

You can check coverage with `pytest --cov=usenc`.

## Documentation

Generate documentation with `python scripts/generate_docs.py`.

Run `mkdocs serve` and check in your browser if the docs are correct.

## Best Practices

### 1. Follow the Interface

Implement both `encode` and `decode`. In the rare case where `decode` does not make sense (like a hash function), implement only `encode`.

### 2. Handle Edge Cases

```python
@staticmethod
def encode(text: str) -> str:
    # Handle empty string
    if not text:
        return ''

    # Handle special characters
    # Handle encoding errors
    try:
        result = do_encoding(text)
    except Exception as e:
        # Handle gracefully or raise as DecodeError
        raise DecodeError('encoder_name', 'text')

    return result
```

### 4. Keep Parameters Consistent

Look at the various parameters in encoders and try to keed the same names and meanings.

For instance `include`/`exclude` like the URL encoder can be used in many encoders.

### 5. UTF-8 Support

Always handle UTF-8 properly:

```python
# When working with bytes
text.encode('utf-8')
bytes_data.decode('utf-8')
```

## Example: Complete Encoder

Here's a complete example with all best practices:

```python
from .base import Encoder, DecodeError
import re

class HexEncoder(Encoder):
    """
    Hexadecimal string encoding

    Encodes each character with its hex representation

    Examples:
    hello world -> 68656C6C6F20776F726C64
    url$param+ -> 75726C253234706172616D253242
    """

    params = {
        'prefix': {
            'type': str,
            'default': '',
            'help': 'Prefix string to each encoded character'
        },
        'include': {
            'type': str,
            'default': 'all',
            'help': 'Characters that should be encoded (can contain \'all\' or \'utf8\')'
        },
        'exclude': {
            'type': str,
            'default': '',
            'help': 'Characters that should not be encoded'
        },
        'lowercase': {
            'action': 'store_true',
            'help': 'Use lowercase hex digits'
        }
    }

    tests = Encoder.tests | {
        'prefix': '--prefix 0x',
        'include': '--prefix 0x --include ghij',
        'exclude': '--exclude abcd',
        'include_all': '--include all',
        'include_all_except_one': '--include all --exclude g',
        'lowercase': '--lowercase'
    }

    @staticmethod
    def encode(text: str, prefix: str = '', include: str = '', exclude: str = '', lowercase: bool = False) -> str:
        include_utf8 = 'utf8' in include
        include = include.replace('utf8', '')
        include_all = 'all' in include
        include = include.replace('all', '')

        include_set = set(include)
        exclude_set = set(exclude)
        hex_format = prefix + ('{:02x}' if lowercase else '{:02X}')

        enc_string = ""
        for c in text:
            if c in exclude_set:
                enc_string += c
            else:
                if c in include_set or include_all or (include_utf8 and not c.isascii()):
                    for x in c.encode('utf-8'):
                        enc_string += hex_format.format(x)
                else:
                    enc_string += c

        return enc_string

    @staticmethod
    def decode(text: str, prefix: str = '', include: str = '', exclude: str = '', lowercase: bool = False) -> str:
        def decode_hex_str(match):
            hex_prefixed_str = match.group(0)
            hex_str = ''.join([hex_prefixed_str[i:i+2] for i in range(len(prefix), len(hex_prefixed_str), len(prefix) + 2)])
            return bytes.fromhex(hex_str).decode('utf-8')

        try:
            return re.sub(f'({prefix}([a-fA-F0-9]{{2}}))+', decode_hex_str, text)
        except UnicodeDecodeError:
            raise DecodeError('hex', text)
```

## Next Steps

- Submit a pull request
- Share your encoder with the community!
